# 7.整数反转

# 题目：

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-integer

# 解法一：

## 思路：

先处理掉x==-2^31次方的情况(不然去符号时会溢出），取出x的符号，然后将x的绝对值存入字符数组，判断其反转后是否越界，然后将字符数组存入int变量结合符号输出。

## 实现：

### 具体：

直接将x从低位到高位，逐位存入end数组`end[++len] = 48|(x%10)`，先判断x的位数是否等于10，若小于10直接反转数组到int，并输出，若等于10，需判断反转后是否会越界，越界则输出0，否则反转数组到int，并输出。



len变量：作为赋值的下标（从1开始）同时还是x的位数。我们知道只有x的位数大于等于10位时（因为2^31=2147483648），反转后才有可能超出范围。所以当x小于10位时就直接反转，等于10位时才对其判断。

`48|(x%10)`等价于`(x%10)+'0'`

判断函数：对于位数为10的数字x=1234567890，则end数组存的就是'0987654321'，将其高9位于与edg数组214748364比较，从高位向低位比较，任意一位大于egd就算溢出，直到比完高9位，对于第十位也就是个位，根据x初始的正负来判断是否溢出。



### 代码：

```c++
class Solution {
public:
    bool isOver(char *end, int f) {
        char edg[12] = "0214748364";//end存数的小标从1开始
        int i = 1;
        while(i <= 9) {
            if(end[i] < edg[i])
                return false;
            else if(end[i] > edg[i])
                return true;
            else
                i++;
        }
        if((f < 0 && end[i] <= '8') || (f > 0 && end[i] <= '7'))
            return false;
        else
            return true;
            
    }
    int reverse(int x) {
        char end[15];
        if(x == 0)
            return 0;
        int f = 1;
        if(x == -2147483648)
            return 0;
        if(x < 0) {
            f = -1;
            x = -x;
        }
        int len = 0, i = 1;
        while(x) {
            end[++len] = 48|(x%10);
            x /= 10;
        }
        if(len == 10) {
            if(isOver(end, f))
                return 0;
        }
        while(len-i) {
            x += end[i] - 48;
            x *= 10;
            i++;
        }
        x += end[i] - 48; 
        return x*f;
    }
};
```

### 小细节：

给的x是32位有符号整数，所以x在int型整数范围内，存数的字符数组的位数有11位足矣。



# 解法二：

## 思路：

可以想象成将x从低位到高位依次推入res的低位，同时res原来的低位向高位挪。在挪和推入的过程中判断溢出。

### 具体：

先预先处理下x为-2^31的情况，然后取出x的符号到f，则x无论正负均可作相同的操作后将结果乘以符号变量f输出。

通过x%10可取出x的最低位，1、`res = res * 10+(x%10)`，可以使res所有位向高位挪一位，同时放入x的最低位，2、x/=10来更新最低位；循环上面1、2、操作直至x为0，得到反转结果。

在**挪**（即res * 10操作）和**放入**（即+(x%10)操作）的过程中，只有当反转后的值为10位数且大于2147483647时才会溢出，但由于res只能为int型整数，当计算到res为9位数时且x还没转换完时，若有可能溢出（即res>214748364且x>0时），再作res*10会导致编译器报错，所有在res计算到9位数且x>0时就应该判断res是否大于214748364，若大于直接返回0，否则继续转换。

其实作了以上判断就已经足够了，细心的话可能会考虑到res == 214748364且x>0的情况，其实由于x的初始值位int型，当反转前x的低9位能为463847412时，最高位就只能为1了，为2都不能满足x是32位有符号的整数的初始条件。



```c++
class Solution {
public:
    int reverse(int x) {
        int res = 0, f = 1;
        if(x == -2147483648) return 0;
        if(x < 0) {
            f = -1;
            x = -x;
        }
        while(x) {
            res = res * 10 + (x%10);
            x /= 10;
            if(res > 214748364 && x > 0)
                return 0; 
        }
        return res * f;
    }
};
```

# 拓展搜索

c++中作取余操作有符号存在时，先取出被余数的符号，然后对两操作数的绝对值作取余操作，结果加上被余数的符号即可。